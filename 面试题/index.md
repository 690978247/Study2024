### 浏览器

#### 浏览器渲染过程

1. 渲染主线程 解析HTML (HTML节点， CSSOM, DOM)
为了提高解析效率，浏览器会启动一个线程预解析率先下载和解析 css

``` eg
 如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因

 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码执行过程中可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因
```

在第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中

2. 样式计算
<!-- 为了得到每个节点的最终样式（计算后的样式。所有的css 属性都得要有值） -->
主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb(255,0,0); 相对单位会变成绝对单位，比如 em 会变成 px

这一步完成后，会得到一棵带有样式的 DOM 树

3. 布局

DOM 树和 Layout 树不一定是一一对应的（display:none 元素不会在布局树中显示， DOM 树 ::before 不存在，但是在layout 树中存在 ）

布局完成后会得到布局树

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置

大部分时候， DOM 树和布局树并非一一对应

比如 display: none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应

4. 分层

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层级改变后，仅会对该层进行后续处理，从而提高效率

滚动条、堆叠上下文、transform、opactity 等样式都会或多或少的影响分层结果，也可以通过 will-change 属性更大程度的影响分层结果

5. 绘制

这里的绘制，是为每一层生成如何绘制的指令

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成

合成线程首先对每个图层进行分块，将其划分为更多的小区域

它会从线程池中拿取多个线程来完成分块工作

``` render
渲染主线程的工作到此为止，剩余步骤交给其他线程完成
```

6. 分块（其他线程 合成线程）

分块会将每一层分为多个小区域

分块的工作是交给多个线程同时进行的

（合成线程首先对每个图层进行分块，将其划分为更多的小区域

它会从线程池中拿取多个线程来完成分块工作）

7. 光栅化

光栅化是将每个块变成位图

优先处理靠近视口的块

此过程会用到 GPU 加速

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块

光栅化的结果，就是一块一块的位图

8. 画- draw

合成线程计算出每个位图在屏幕上的位置，交给 GPU 进行最终呈现

最后一个阶段就是画了

合成线程拿到每个层、每个块的位图后，生成一个个 [指引(quad)]信息

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形

变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像

**面试问题：**

1. 什么是 reflow ?

reflow 的本质就是重新计算 layout 树

当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout

为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的

也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息

浏览器在反复权衡下，最终决定获取属性立即reflow

``` eg
浏览器在反复权衡下，最终决定获取属性立即reflow。所以可以使用 dom.clientWidth 实现强制重新布局
```

2. 什么是 repaint ?

repaint 的本质就是重新根据分层信息计算了绘制指令

当改动了可见样式后，就需要重新计算，会引发 repaint

由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint

3. 为什么 transform 效率高？

通过 js 进行 transform 属性修改时，由于CSSOM 树变化 会触发主线程的 2.style 样式计算步骤 和 合成线程的 8 draw步骤

使用 animation 修改 transform 属性时，只会触发 8 draw 步骤，主线程无感

所以效率极高


### CSS

#### BFC

BFC（Block Formatting Context，块级格式化上下文）是 CSS 规范中的一个概念,它定义了一个独立的渲染区域，用于控制在改区域内元素的布局行为。BFC的主要作用是确保元素在布局中遵循特定的规则，避免或解决布局中的一些常见问题

**特点：**

- 清除浮动：BFC能包含浮动元素并能清除他们。具体来说，BFC内部的元素（包括浮动元素）不会影响外部的元素，而BFC外部的元素也不会影响BFC内部的布局。换句话说，BFC是一个容器，它隔离了内部和外部的浮动
- 高度自适应：BDC会在内部根据其内容的高度自动扩展，这意味着他会处理包含浮动元素的高度，避免了父元素高度塌陷的问题
- 元素之间不会发生重叠： BFC 内的元素会按照标准的块级元素布局规则垂直排列
- 不受外部浮动影响：BFC内的浮动元素不会影响到外部元素，反之亦然

**触发BFC的条件：**
BFC 的行为是由 CSS 属性触发的，以下是一些会触发 BFC 的常见条件：

- 根元素<html>: 所有文档的根元素自动处于BFC中
- 浮动元素（float）: 任何元素设置了`float`属性，且其值不为`none`，都会触发 BFC
- 绝对定位元素：absoulte, fixed 会触发BFC
- 内联块元素：inline-block
- 块级格式化上下文： display: flow-root
- 表格单元格：display: table-cell
- flex和grid容器：display:flex、display:grid

**常见应用场景:**

- 清除浮动
- margin合并问题
- 高度塌陷
- 布局中子元素重叠问题

**如何触发：**

- 父元素 overflow: hidden,auto, scroll等
- 父元素 position: relative, absolute, fixed, sticky
- 父元素 display: flow-root，flex 或 grid

### JS

#### JS 为什么会阻碍渲染？

因为 JS 是单线程的，JS 代码执行和页面渲染都在一个线程上面，执行js时页面渲染会等待js执行完成之后才会继续执行

### 工程化

#### 什么是前端工程化？

前端工程化是指在前端开发过程中，通过一系列标准化、模块化、工具化、自动化的方法，提高开发效率，代码质量和团队协作能力的实践

带来的意义：

- 提高开发效率
- 提升代码质量
- 增强团队协作
- 提高项目可维护性
- 加速项目交付

#### Webpack 和 Vite 有什么区别? 各自优缺点是什么?

webpack和 vite 都是前端构建工具，但它们在构建理念和实现方式上有较大区别

webpack 是一种模块打包工具，主要功能是将各种资源（如 Javascript、Css、图片等）通过 loader 和 plugin 转换和打包成可以直接在浏览器中运行的代码，其核心思想是以代码分割、按需加载和优化资源来提升性能

vite 是一种新型构建工具，利用原生（ESM）和现代浏览器特性，提供快速开发和构建体验。vite 的核心思想是在开发环境中直接利用浏览器的 ESM 功能，以提升启动和热更新速度

**webpack 优缺点：**

- 优点：
  - 高度可配置，可以应对各种复杂的项目需求
  - 社区资源丰富，有大量的loader和plugin可以使用
  - 得到了广泛的应用和支持，在生产环境中非常成熟和稳定

- 缺点
  - 配置较为复杂，新手上手难度高
  - 开发环境下编译速度较慢，尤其是在大项目中
  - 热更新（HMR）速度慢

**vite 优缺点**

- 优点：
  - 开发环境下编译速度快，启动速度快。因为它是基于现代浏览器的 ESM 处理
  - 热更新速度非常快，几乎是瞬时的。
  - 开箱即用，配置较为简单，适合小型和中型项目

- 缺点：
  - 生态系统不如webpack丰富，某些复杂需求需要自定义解决方案
  - 在某些环境下会有兼容性问题
  - 生产环境打包速度和webpack相差无几，但没有webpack成熟

### webpack

#### webpack 核心原理

webpack的核心原理是通过模块打包的方式将代码和资源转化为浏览器可执行的静态文件。它会递归的解析项目中的各种依赖，然后通过loader和plugin进行代码转换和扩展，最终生成优化后的静态资源文件。具体来说，它主要包括入口（entry）、输出（output）、loader、plugin、和模式（mode）五个核心概念

要更详细的理解webpack的核心原理，我们需要了解以下几个方面

- 模块化依赖管理：webpack 是一个模块打包工具，它通过配置入口文件来解析项目中的模块依赖关系。它会从入口文件出发，递归的将各个依赖的模块和资源打包在一起。
- loader: webpack 本身只理解 Javascript, 但项目中可能包含各种各样的静态资源（比如CSS, 图片）。loader 是一种文件转换器，它用于将非 Javascript 文件转换为webpack可以识别和处理的模块。常用的loader包括css-loader,style-loader, babel-loader,file-loader等。
- plugin: 插件用于扩展webpack的功能，插件的范围非常广泛，可以用来优化打包后的代码、自动生成HTML文件、进行代码分割等。常见的插件包括HtmlWebpackPlugin, CleanWebpackPlugin, MiniCssExtractPlugin等。
- 输出：输出定义了打包后文件存放路径和文件名。webpack 会根据配置将打包生成的文件输出到指定的文件中
- 模式（mode）: webpack 有两种模式：开发模式（develop）和生产模式（production）。开发模式侧重与提升构建速度和调试体验，而生产模式则会进行代码压缩和优化以提高效率。

总结来说，webpack 的核心原理在于通过配置文件来描述模块之间的依赖关系，使用loader处理不同类型的文件，并通过插件扩展功能，最终生成浏览器使用的静态资源文件。这种机制大幅度提高了前端开发的效率和代码的可维护性

#### Webpack的 Tree Shaking 机制的原理是什么?

通过静态分析代码的模块依赖图，将未使用的代码移除掉，主要依赖于ES6 的模块系统

**过程：**

1. **标记（Marking）**: Webpack 会从入口文件出发，递归的分析代码中的模块依赖，标记出用到的模块和导出的函数或变量
2. **摇树（Shaking）**: 基于上一步的标记结果，Webpack会移除未被使用的模块和代码（即那些没有被标记的部分）
3. **生成（Bundle Generation）**: 最后，Webpack会生成最终的打包文件，只包含被使用的必要代码

Tree Shaking 的前提是对代码进行静态分析。静态分析是一种在无需运行代码的情况下，基于代码的语法和结构，分析代码的行为以及性能的方法。Webpack 使用的是 UglifyJS/Terser 插件来完成这项工作

webpack5 可以使用 Esbuild?

#### 如何使用 webpack 进行异步加载？

Webpack 的异步加载主要是通过`import()`语法。这种方法可以让我们在需要某个模块时再进行加载，而不是在初始加载时一次性加载所有模块，从而提高性能和首屏加载速度。Webpack 会根据这个语法将模块打包成独立的文件，等到实际使用时才进行加载

**1.使用场景：**

-当某些模块是只有在某些用户操作（比如点击按钮）时才需要加载
-页面中有一些非常大的模块,但初始访问时并不需要它们

**2.实例代码：**

``` eg
// 普通import语法
import something from './module'

// 异步加载
document.getElementById('myButton').addEventListener('click', () => {
  import('./module').then(module => {
    //模块加载成功，现在可以使用其导出的内容
    const something  = module.default
    something.dosomething()
  }).catch(err => {
    console.error('模块加载失败'，err)
  })
})

```

**3. Webpack 配置：**
通常情况下，只需要在项目中安装好 Webpack 和其所需的 Loader 和插件，Webpack默认就可以支持`import()`语法，无需额外配置。

**4. 代码分离：**
Webpack 的代码分离功能不仅可以通过异步加载实现，还可以通过`entry`配置、`SplitChunksPlugin` 插件等不同的方法来优化代码分离。以下是通过`SplitChunkPlugin`插件分离第三方库(如`lodash`)的示例：

``` javascript
// webpack.config.js
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  }
}

```



### Vue

#### Vue 常见优化手段

1.使用Key

- 对于通过循环生成的列表，应给每个列表项一个稳定且唯一的key, 这有利于在列表变动时，尽量少的删除、新增、改动元素

2.使用冻结的对象

- 冻结的对象不会被响应化

3.使用函数式组件
